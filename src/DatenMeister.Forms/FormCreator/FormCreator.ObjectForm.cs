using DatenMeister.Core.EMOF.Implementation;
using DatenMeister.Core.EMOF.Interface.Common;
using DatenMeister.Core.EMOF.Interface.Reflection;
using DatenMeister.Core.Helper;
using DatenMeister.Core.Models;
using DatenMeister.Core.Models.EMOF;
using DatenMeister.Core.Uml.Helper;

namespace DatenMeister.Forms.FormCreator;

public partial class FormCreator
{
    /// <summary>
    ///     Creates the extent form for a specific object which is selected in the item explorer view.
    ///     This is the typical method that is used to create the form via the FormFinder
    /// </summary>
    /// <param name="element">Element which shall be shown</param>
    /// <param name="creationMode">The creation mode for auto-generation of the fields</param>
    /// <returns>Created Extent form as MofObject</returns>
    public IElement CreateObjectFormForItem(
        IObject element,
        FormFactoryConfiguration creationMode)
    { 
        if (_workspaceLogic == null)
            throw new InvalidOperationException("WorkspaceLogic is null");

        var factory = GetMofFactory(creationMode);

        var cache = new FormCreatorCache();

        // Creates the empty form
        var objectForm = factory.create(_Forms.TheOne.__ObjectForm);
        objectForm.set(
            _Forms._ObjectForm.name, 
            $"Object Form for '{NamedElementMethods.GetName(element)}'");
        objectForm.set(_Forms._ObjectForm.isAutoGenerated, true);

        FormMethods.AddToFormCreationProtocol(
            objectForm,
            "[FormCreator.CreateObjectFormForItem]: Create Object Form");

        var objectMetaClass = (element as IElement)?.getMetaClass();

        var tabs = new List<IElement>();

        // Get all properties of the elements
        var flagAddByMetaClass = creationMode.CreateByMetaClass;
        var propertyNamesWithCollection = new List<P>();
        var propertyNamesWithoutCollection = new List<P>();

        // Adds the properties by the stored properties of the element
        if (creationMode.CreateByPropertyValues)
        {
            var properties = (element as IObjectAllProperties)?.getPropertiesBeingSet().ToList();
            properties ??= new List<string>();

            propertyNamesWithCollection = (from p in properties
                where element.IsPropertyOfType<IReflectiveCollection>(p)
                let propertyContent = element.get<IReflectiveCollection>(p)
                where propertyContent != null
                select new P { PropertyName = p }).ToList();

            propertyNamesWithoutCollection = (from p in properties
                where !element.IsPropertyOfType<IReflectiveCollection>(p)
                let propertyContent = element.get(p)
                where propertyContent != null
                select new P { PropertyName = p }).ToList();
        }

        // Adds the properties by the metaclasses
        if (flagAddByMetaClass && objectMetaClass != null)
        {
            var metaClassProperties = ClassifierMethods.GetPropertiesOfClassifier(objectMetaClass);
            foreach (var property in metaClassProperties)
            {
                if (PropertyMethods.IsCollection(property))
                {
                    propertyNamesWithCollection.Add(
                        new P
                        {
                            PropertyName = NamedElementMethods.GetName(property),
                            PropertyType = PropertyMethods.GetPropertyType(property),
                            Property = property
                        });
                }
                    
                // As temporary workaround, we do also add the collections to the detail view
                propertyNamesWithoutCollection.Add(
                    new P
                    {
                        PropertyName = NamedElementMethods.GetName(property),
                        PropertyType = property,
                        Property = property
                    });
            }
        }

        // Remove duplicate properties in each of the collection
        var propertiesWithCollection =
            from p in propertyNamesWithCollection.Distinct(new P.PropertyNameEqualityComparer())
            let propertyContent = element.get<IReflectiveCollection>(p.PropertyName)
            select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent };

        var propertiesWithoutCollection =
            (from p in propertyNamesWithoutCollection.Distinct(new P.PropertyNameEqualityComparer())
                let propertyContent = element.getOrDefault<object>(p.PropertyName)
                select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent })
            .ToList();

        // Remove properties in propertiesWithoutCollection which are already available in propertiesWithCollection
        propertiesWithoutCollection = propertiesWithoutCollection
            .Where(x => propertiesWithCollection.All(y => y.propertyName != x.propertyName))
            .ToList();
            
        // We start with the detail form of type RowForm, we always need to have that form
        // because additional plugins might also add certain buttons to that form
        var detailForm = factory.create(_Forms.TheOne.__RowForm);
        detailForm.set(_Forms._RowForm.name, "Detail");
        detailForm.set(_Forms._RowForm.isAutoGenerated, true);
            
        tabs.Add(detailForm);
            
        FormMethods.AddToFormCreationProtocol(
            objectForm,
            "[FormCreator.CreateObjectFormForItem]: Create DetailForm into Extent");
            
        // Now, we got
        // propertyNamesWithCollection containing all properties which have a collection as a subitem ==> List Form
        // propertyNamesWithoutCollection containing all properties which have a collection as a subitem ==> Detail Form
        if (propertiesWithoutCollection.Any() || creationMode.AutomaticMetaClassField)
        {
            FormMethods.AddToFormCreationProtocol(
                objectForm,
                "[FormCreator.CreateObjectFormForItem]: Create DetailForm into Extent");

            foreach (var pair in propertiesWithoutCollection)
            {
                if (pair.propertyName == null)
                {
                    continue;
                }

                var property =
                    objectMetaClass == null
                        ? null
                        : ClassifierMethods.GetPropertyOfClassifier(objectMetaClass, pair.propertyName);

                var field = CreateFieldForProperty(property,
                    pair.propertyName,
                    creationMode);
                detailForm.AddCollectionItem(_Forms._RowForm.field, field);

                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Added field to DetailForm: " +
                    NamedElementMethods.GetName(field));
            }

            // Adds the metaclass field if not already added
            if (!cache.MetaClassAlreadyAdded
                && creationMode.AutomaticMetaClassField
                && !FormMethods.HasMetaClassFieldInForm(
                    detailForm.get<IReflectiveCollection>(_Forms._RowForm.field)!))
            {
                // Add the element itself
                var metaClassField = factory.create(_Forms.TheOne.__MetaClassElementFieldData);
                metaClassField.set(_Forms._MetaClassElementFieldData.name, "Metaclass");
                detailForm.AddCollectionItem(_Forms._RowForm.field, metaClassField);

                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Added metaclass to DetailForm");

                cache.MetaClassAlreadyAdded = true;
            }
        }

        // Adds the properties with collection by adding table forms
        foreach (var pair in propertiesWithCollection)
        {
            var propertyName = pair.propertyName;
            var elementsAsObjects = pair.propertyContent.OfType<IObject>().ToList();

            // Special handling for packagedElement as container property for the childrens
            if (propertyName == _UML._Packages._Package.packagedElement)
            {
                // If the property for the list is 'packagedElement', then create multiple subforms...
                var elementsWithoutMetaClass = elementsAsObjects.Where(x =>
                {
                    if (x is IElement innerElement) return innerElement.getMetaClass() == null;

                    return true;
                }).ToList();

                var elementsWithMetaClass = elementsAsObjects
                    .OfType<IElement>()
                    .Select(x=>x.getMetaClass())
                    .Where(x => x != null)
                    .Distinct(new P.MofObjectComparer());

                if (elementsWithoutMetaClass.Any() || !elementsAsObjects.Any())
                {
                    // If there are elements included and they are filled
                    // OR, if there is no element included at all, create the corresponding list form
                    var form = factory.create(_Forms.TheOne.__TableForm);
                    form.set(_Forms._TableForm.name, "packagedElements without MetaClass");
                    form.set(_Forms._TableForm.property, propertyName);
                    form.set(_Forms._TableForm.noItemsWithMetaClass, true);
                    form.set(_Forms._TableForm.isAutoGenerated, true);

                    foreach (var item in elementsWithoutMetaClass)
                    {
                        AddFieldsToForm(form, item, creationMode, cache);
                    }

                    FormMethods.AddToFormCreationProtocol(
                        objectForm,
                        "[FormCreator.CreateObjectFormForItem]: Added specific Sub-TableForm for 'packagedElement' of propertyType: " +
                        NamedElementMethods.GetName(pair.propertyType));
                        
                    FormMethods.RemoveDuplicatingDefaultNewTypes(form);

                    tabs.Add(form);
                }

                foreach (var metaClass in elementsWithMetaClass)
                {
                    // Now try to figure out the metaclass
                    if (_formLogic != null)
                    {
                        FormMethods.AddToFormCreationProtocol(
                            objectForm,
                            "[FormCreator.CreateObjectFormForItem]: Add Table Form for metaclass:" +
                            NamedElementMethods.GetName(metaClass));

                        var form = _parentFormFactory.CreateTableFormForProperty(
                            element,
                            propertyName,
                            metaClass,
                            new FormFactoryConfiguration { 
                                CreateByMetaClass = creationMode.CreateByMetaClass,
                                CreateByPropertyValues = creationMode.CreateByPropertyValues,
                                AllowFormModifications = false });
                        if (form != null)
                        {
                            tabs.Add(form);
                        }
                    }
                    else
                    {
                        FormMethods.AddToFormCreationProtocol(
                            objectForm,
                            "[FormCreator.CreateObjectFormForItem]: Add Table Form for metaclass:" +
                            NamedElementMethods.GetName(metaClass));

                        tabs.Add(
                            CreateTableFormForProperty(null, pair.propertyName, metaClass,
                                creationMode with { AllowFormModifications = false }));
                    }
                }
            }
            else
            {
                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Add Table Form for by reflective collection: " +
                    propertyName);

                // If there are elements included and they are filled
                // OR, if there is no element included at all, create the corresponding list form
                var form = _parentFormFactory.CreateTableFormForCollection(
                    new TemporaryReflectiveCollection(elementsAsObjects),
                    creationMode with { AllowFormModifications = false });
                if (form != null)
                {
                    form.set(_Forms._TableForm.name, $"Property: {propertyName}");
                    form.set(_Forms._TableForm.property, propertyName);

                    // Adds the form to the tabs
                    tabs.Add(form);

                    var propertyType = pair.propertyType;
                    if (propertyType != null)
                    {
                        // Inhibit Unclassified Item in case the property type is set
                        // Addendum: We decided to allow to create an unclasssified item. 
                        //form.set(_Forms._TableForm.inhibitNewUnclassifiedItems, true);

                        // Add the fields to the form
                        AddFieldsToRowOrTableFormByMetaClass(form, propertyType, creationMode, cache);
                        FormMethods.AddDefaultTypeForNewElement(form, propertyType);

                        FormMethods.AddToFormCreationProtocol(
                            form,
                            "[FormCreator.CreateObjectFormForItem]: Add DefaultTypeForNewElement driven by ExtentType: " +
                            NamedElementMethods.GetName(propertyType));
                    }
                }
            }
        }

        // ReSharper restore HeuristicUnreachableCode
        objectForm.set(_Forms._ObjectForm.tab, tabs);

        CleanupObjectForm(objectForm);
        return objectForm;
    }
        
    /// <summary>
    ///     Creates an extent form containing the subforms
    /// </summary>
    /// <param name="factory">The factory being used</param>
    /// <param name="tabsAsForms">The Forms which are converted to an extent form</param>
    /// <returns>The created extent</returns>
    public static IElement CreateObjectFormFromTabs(IFactory? factory, params IElement[] tabsAsForms)
    {
        factory ??= new MofFactory(tabsAsForms.First());
        var result = factory.create(_Forms.TheOne.__ObjectForm);
        result.set(_Forms._RowForm.isAutoGenerated, true);
        result.set(_Forms._CollectionForm.tab, tabsAsForms);
        return result;
    }

    /// <summary>
    /// Creates an object form by the definition of a metaclass
    /// </summary>
    /// <param name="metaClass">MetaClass to be handled</param>
    /// <param name="configuration">Configuration of the Form Factory</param>
    /// <returns>The returned Object Form</returns>
    public IElement CreateObjectFormForMetaClass(IElement metaClass, FormFactoryConfiguration configuration)
    {
        var factory = GetMofFactory(configuration);
        var result = factory.create(_Forms.TheOne.__ObjectForm);
        result.set(_Forms._RowForm.isAutoGenerated, true);
        result.set(
            _Forms._RowForm.name,
            $"Object Form for '{NamedElementMethods.GetFullName(metaClass)}'");
            
        var rowForm = _parentFormFactory.CreateRowFormByMetaClass(metaClass, configuration);
        result.set(_Forms._CollectionForm.tab, new []{rowForm});
        return result;
    }
}