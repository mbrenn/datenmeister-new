using System.Globalization;
using DatenMeister.Core;
using DatenMeister.Core.EMOF.Interface.Common;
using DatenMeister.Core.EMOF.Interface.Reflection;
using DatenMeister.Core.Helper;
using DatenMeister.Core.Models;
using DatenMeister.Core.Models.EMOF;
using DatenMeister.Core.Runtime;
using DatenMeister.Core.Runtime.Workspaces;
using DatenMeister.Core.Uml.Helper;
using DatenMeister.Forms.FormFactory;

namespace DatenMeister.Forms.FormCreator;

public class TableFormCreator : FormCreator, ITableFormFactory
{
    public TableFormCreator(IWorkspaceLogic workspaceLogic, IScopeStorage scopeStorage)
    : base(workspaceLogic, scopeStorage)
    {
        
    }
    
    /// <summary>
    ///     Creates the list form out of the elements in the reflective collection.
    ///     Supports the creation by the metaclass and by the object's properties
    /// </summary>
    /// <param name="elements">Elements to be queried</param>
    /// <param name="creationMode">The used creation mode</param>
    /// <returns>The created list form </returns>
    public IElement CreateTableFormForCollection(
        IReflectiveCollection elements,
        FormFactoryContext creationMode)
    {
        var result = GetMofFactory(creationMode).create(_Forms.TheOne.__TableForm);
        result.set(_Forms._TableForm.isAutoGenerated, true);
            
        AddToTableFormByElements(result, elements, creationMode with { IsForTableForm = true });

        CleanUpTableForm(result);
            
        return result;
    }

    /// <summary>
    ///     Creates a list form for a certain metaclass being used inside an extent form
    /// </summary>
    /// <param name="element">Element being used to determine the propertytype... But this is empty</param>
    /// <param name="propertyName">Name of the property</param>
    /// <param name="propertyType"></param>
    /// <param name="creationMode"></param>
    public IElement CreateTableFormForProperty(
        IObject? element,
        string propertyName,
        IElement? propertyType,
        FormFactoryContext creationMode)
    {
        if (!creationMode.CreateByMetaClass)
            throw new InvalidOperationException("The list form will only be created for the metaclass");

        var tableFormForPropertyValues = GetMofFactory(creationMode).create(_Forms.TheOne.__TableForm);
        tableFormForPropertyValues.set(_Forms._TableForm.isAutoGenerated, true);

        FormMethods.AddToFormCreationProtocol(
            tableFormForPropertyValues,
            "[FormCreator.CreateTableFormForProperty]");

        AddFieldsToRowOrTableFormByMetaClass(tableFormForPropertyValues, propertyType, creationMode);
        tableFormForPropertyValues.set(_Forms._TableForm.property, propertyName);
        tableFormForPropertyValues.set(_Forms._TableForm.metaClass, propertyType);
        tableFormForPropertyValues.set(_Forms._TableForm.title,
            $"{propertyName} - {NamedElementMethods.GetName(propertyType)}");
        if (propertyType != null)
        {
            FormMethods.AddDefaultTypeForNewElement(tableFormForPropertyValues, propertyType);
        }

        FormMethods.AddToFormCreationProtocol(
            tableFormForPropertyValues,
            "[FormCreator.CreateTableFormForProperty] Set default type: " +
            NamedElementMethods.GetName(propertyType));

        CleanUpTableForm(tableFormForPropertyValues);
            
        return tableFormForPropertyValues;
    }

    /// <summary>
    ///     Creates a list form for a certain metaclass
    /// </summary>
    /// <param name="metaClass"></param>
    /// <param name="creationMode"></param>
    public IElement CreateTableFormForMetaClass(
        IElement? metaClass,
        FormFactoryContext creationMode)
    {
        return CreateTableFormForMetaClass(metaClass, creationMode, null);
    }

    /// <summary>
    ///     Creates a list form for a certain metaclass
    /// </summary>
    /// <param name="metaClass"></param>
    /// <param name="creationMode"></param>
    /// <param name="property">Property being used</param>
    public IElement CreateTableFormForMetaClass(
        IObject? metaClass,
        FormFactoryContext creationMode,
        IElement? property = null)
    {
        if (!creationMode.CreateByMetaClass)
            throw new InvalidOperationException("The list form will only be created for the metaclass");

        var form = GetMofFactory(creationMode).create(_Forms.TheOne.__TableForm);
        var realPropertyName = NamedElementMethods.GetName(property);
        var propertyName = property != null ? realPropertyName : "";
        form.set(_Forms._TableForm.isAutoGenerated, true);

        FormMethods.AddToFormCreationProtocol(
            form,
            "[FormCreator.CreateTableFormForMetaClass] Created for: " + NamedElementMethods.GetName(metaClass));

        var title =
            (metaClass != null ? "'" + NamedElementMethods.GetName(metaClass) + "'" : string.Empty) +
            (metaClass != null && !string.IsNullOrEmpty(propertyName) ? " - " : "") +
            propertyName;

        form.set(_Forms._TableForm.title, "Items of type " + title);
        form.set(_Forms._TableForm.name, title);
        if (property != null)
        {
            form.set(_Forms._TableForm.property, realPropertyName);
        }

        if (metaClass != null)
        {
            AddFieldsToRowOrTableFormByMetaClass(form, metaClass, creationMode with { IsForTableForm = true });
                
            FormMethods.AddToFormCreationProtocol(
                form,
                "[FormCreator.CreateTableFormForMetaClass] Added Default Type for: " +
                NamedElementMethods.GetName(metaClass));

            FormMethods.AddDefaultTypeForNewElement(form, metaClass);
            
            // Do not create buttons for unclassified items in the metaclass
            form.set(_Forms._TableForm.inhibitNewUnclassifiedItems, true);
        }
        else
        {
            // Ok, we have no metaclass, but let's add at least the columns for the property 'name'
            AddFieldToFormByMetaClassProperty(
                form,
                _UML.TheOne.CommonStructure.NamedElement._name,
                new FormFactoryContext
                    { CreateByPropertyValues = false, AutomaticMetaClassField = false, IsForTableForm = true },
                FormUmlElementType.Property);
        }

        CleanUpTableForm(form);
            
        return form;
    }
    
    
    /// <summary>
    ///     Takes the given uml item and includes it into the form.
    ///     The element can be of type enumeration, class or property.
    ///     For the creation rules, see chapter "FormManager" in the Documentation
    /// </summary>
    /// <param name="form">Form that will be enriched. It may be an object, collection, row oder table form</param>
    /// <param name="umlClassOrProperty">The uml element, property, class or type that will be added</param>
    /// <param name="creationMode">The creation mode</param>
    /// <param name="umlElementType"></param>
    /// <returns>true, if an element was created</returns>
    public bool AddFieldToFormByMetaClassProperty(
        IElement form,
        IElement umlClassOrProperty,
        FormFactoryContext creationMode,
        FormUmlElementType umlElementType = FormUmlElementType.Unknown)
    {
        ArgumentNullException.ThrowIfNull(form);
        ArgumentNullException.ThrowIfNull(umlClassOrProperty);

        var noDuplicate = true;

        // First, select the type of the form
        var isRowForm =
            ClassifierMethods.IsSpecializedClassifierOf(form.getMetaClass(),
                _Forms.TheOne.__RowForm);
        var isTableForm =
            ClassifierMethods.IsSpecializedClassifierOf(form.getMetaClass(),
                _Forms.TheOne.__TableForm);
        var isCollectionForm =
            ClassifierMethods.IsSpecializedClassifierOf(form.getMetaClass(),
                _Forms.TheOne.__CollectionForm);
        var isObjectForm =
            ClassifierMethods.IsSpecializedClassifierOf(form.getMetaClass(),
                _Forms.TheOne.__ObjectForm);
        var isNoneOfTheForms = !(isRowForm || isTableForm || isCollectionForm || isObjectForm);
        if (isNoneOfTheForms)
            throw new InvalidOperationException("Given element is not a detail, a list, a collection or table form");

        // Second, select the type of the umlElement
        var isPropertyUml =
            umlElementType == FormUmlElementType.Unknown &&
            ClassifierMethods.IsSpecializedClassifierOf(umlClassOrProperty.getMetaClass(),
                _UML.TheOne.Classification.__Property)
            || umlElementType == FormUmlElementType.Property;
        var isClassUml =
            umlElementType == FormUmlElementType.Unknown &&
            ClassifierMethods.IsSpecializedClassifierOf(umlClassOrProperty.getMetaClass(),
                _UML.TheOne.StructuredClassifiers.__Class)
            || umlElementType == FormUmlElementType.Class;
        var isEnumerationUml =
            umlElementType == FormUmlElementType.Unknown &&
            ClassifierMethods.IsSpecializedClassifierOf(umlClassOrProperty.getMetaClass(),
                _UML.TheOne.SimpleClassifiers.__Enumeration)
            || umlElementType == FormUmlElementType.Enumeration;
        var isNoneOfTheUml = !(isPropertyUml || isClassUml || isEnumerationUml);
        if (isNoneOfTheUml)
            throw new InvalidOperationException(
                "Given element is not a property, not a class, not an enumeration.");

        // First, let's parse the properties
        if (isRowForm && isPropertyUml || isTableForm && isPropertyUml)
        {
            if (noDuplicate && FormMethods.GetField(form, NamedElementMethods.GetName(umlClassOrProperty)) != null)
                // Field is already existing
                return false;

            var fieldFactory = new FieldCreator(WorkspaceLogic, ScopeStorage);
            var column = fieldFactory.CreateFieldForProperty(umlClassOrProperty,
                null,
                creationMode);
            form.get<IReflectiveCollection>(_Forms._RowForm.field).add(column);

            FormMethods.AddToFormCreationProtocol(form,
                "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Property to row or table form: " +
                NamedElementMethods.GetName(column));
            return true;
        }

        if (isCollectionForm && isPropertyUml || isObjectForm && isPropertyUml)
        {
            var isPropertyACollection = PropertyMethods.IsCollection(umlClassOrProperty);

            if (!isPropertyACollection)
            {
                // Property is a single element, so a field is added to the detail form, if not already existing
                var detailForm = FormMethods.GetOrCreateRowFormIntoForm(form);
                var result = AddFieldToFormByMetaClassProperty(detailForm, umlClassOrProperty, creationMode);

                FormMethods.AddToFormCreationProtocol(form,
                    "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Property to Collection Form: " +
                    NamedElementMethods.GetName(umlClassOrProperty));

                return result;
            }

            var propertyName = umlClassOrProperty.getOrDefault<string>(_UML._CommonStructure._NamedElement.name);
            if (noDuplicate && FormMethods.GetTableFormForPropertyName(form, propertyName) != null)
            {
                // List form is already existing
                return false;
            }

            // Property is a collection, so a list form is created for the property
            var tabs = form.get<IReflectiveCollection>(_Forms._CollectionForm.tab);

            // Now try to figure out the metaclass
            var tableFormCreator = new TableFormCreator(WorkspaceLogic, ScopeStorage);
            var listForm = tableFormCreator.CreateTableFormForProperty(
                umlClassOrProperty,
                FormFactoryContext.CreateByMetaClassOnly);

            FormMethods.AddToFormCreationProtocol(form,
                "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Table Form to Collection Form: " +
                NamedElementMethods.GetName(umlClassOrProperty));

            tabs.add(listForm);
            return true;
        }

        // Now, let's parse the enumerations
        if (isRowForm && isEnumerationUml || isTableForm && isEnumerationUml)
        {
            var propertyName = NamedElementMethods.GetName(umlClassOrProperty)
                .ToLower(CultureInfo.InvariantCulture);
            
            var fieldFactory = new FieldCreator(WorkspaceLogic, ScopeStorage);
            var column = fieldFactory.CreateFieldForEnumeration(propertyName, umlClassOrProperty, creationMode);
            form.get<IReflectiveCollection>(_Forms._RowForm.field).add(column);

            FormMethods.AddToFormCreationProtocol(form,
                "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Enumeration to row/table form: " +
                NamedElementMethods.GetName(column));

            return true;
        }

        if (isCollectionForm && isEnumerationUml || isObjectForm && isEnumerationUml)
        {
            var detailForm = FormMethods.GetOrCreateRowFormIntoForm(form);
            var result = AddFieldToFormByMetaClassProperty(detailForm, umlClassOrProperty, creationMode);

            FormMethods.AddToFormCreationProtocol(form,
                "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Enumeration to Collection Form: " +
                NamedElementMethods.GetName(umlClassOrProperty));

            return result;
        }

        // Now the classes... All properties are created into this. 
        if (isClassUml)
        {
            var properties = ClassifierMethods.GetPropertiesOfClassifier(umlClassOrProperty);
            var added = true;
            foreach (var property in properties)
            {
                added &= AddFieldToFormByMetaClassProperty(form, property, creationMode);

                FormMethods.AddToFormCreationProtocol(form,
                    "[FormCreator.AddFieldsToFormByMetaClassProperty]: Added Enumeration to Detail: " +
                    NamedElementMethods.GetName(property));
            }

            return added;
        }

        return false;
    }

    /// <summary>
    ///     Adds the property to the list elements by parsing through the
    /// </summary>
    /// <param name="form">Contains the form which is parsed</param>
    /// <param name="elements">Goes through the elements</param>
    /// <param name="creationMode">The creation mode to be used</param>
    public void AddToTableFormByElements(
        IElement form,
        IReflectiveCollection elements,
        FormFactoryContext creationMode)
    {
        var metaClassAdded = false;
        var onlyCommonProperties = creationMode.IncludeOnlyCommonProperties;

        var cache = new FormCreatorCache();
        var alreadyVisitedMetaClasses = new HashSet<IElement>();

        IObject? firstElementMetaClass = null;

        // Figure out only the elements which have common properties
        var propertyNames = onlyCommonProperties ? new HashSet<string>() : null;

        if (propertyNames != null)
        {
            SelectOnlyCommonPropertyNames(elements, propertyNames, creationMode);

            foreach (var propertyName in propertyNames) cache.FocusOnPropertyNames.Add(propertyName);
        }

        foreach (var element in elements.OfType<IObject>())
        {
            var metaClass = (element as IElement)?.getMetaClass();
            if (firstElementMetaClass == null || !creationMode.AutomaticMetaClassField)
            {
                // If this is the first element or when the reportCreator does not allow the addition
                // of a metaclass
                firstElementMetaClass = metaClass;
            }
            else if (!Equals(firstElementMetaClass, metaClass)
                     && !metaClassAdded
                     && !cache.MetaClassAlreadyAdded
                     && creationMode.AutomaticMetaClassField
                     && !FormMethods.HasMetaClassFieldInForm(form))
            {
                metaClassAdded = true;
                cache.MetaClassAlreadyAdded = true;

                // Create the metaclass as a field
                var metaClassField = GetMofFactory(creationMode).create(_Forms.TheOne.__MetaClassElementFieldData);
                metaClassField.set(_Forms._MetaClassElementFieldData.name, "Metaclass");
                metaClassField.set(_Forms._MetaClassElementFieldData.title, "Metaclass");
                form.get<IReflectiveSequence>(_Forms._TableForm.field).add(0, metaClassField);

                FormMethods.AddToFormCreationProtocol(
                    form,
                    "[FormCreator.AddToTableFormByElements] Added metaclass");
            }

            if (creationMode.CreateByMetaClass && metaClass != null)
            {
                if (alreadyVisitedMetaClasses.Contains(metaClass)) continue;

                alreadyVisitedMetaClasses.Add(metaClass);
                AddFieldsToRowOrTableFormByMetaClass(form, metaClass, creationMode with { IsForTableForm = true }, cache);
            }
            else if (creationMode.CreateByPropertyValues)
            {
                AddFieldsToForm(
                    form,
                    element,
                    creationMode with { CreateByMetaClass = false, IsForTableForm = true },
                    cache);
            }

        }
    }

    /// <summary>
    /// Defines the property names to be used when the creation flag contains 'OnlyCommon' Properties
    /// </summary>
    /// <param name="elements">The enumeration of elements which are parsed</param>
    /// <param name="propertyNames">A set of property names which are evaluated. The set is also modified</param>
    /// <param name="creationMode">The creation mode to be used</param>
    private void SelectOnlyCommonPropertyNames(
        IReflectiveCollection elements,
        ISet<string> propertyNames,
        FormFactoryContext creationMode)
    {
        ArgumentNullException.ThrowIfNull(elements);
        ArgumentNullException.ThrowIfNull(propertyNames);

        var firstRun = true;
        var toBeDeleted = new HashSet<string>();

        // Parses the metaclass
        if (creationMode.CreateByMetaClass)
            foreach (var element in elements.OfType<IElement>())
            {
                var metaClass = element.getMetaClass();
                if (metaClass == null) continue;

                var propertiesOfElement =
                    ClassifierMethods.GetPropertyNamesOfClassifier(metaClass)
                        .ToList();

                ThinOutPropertyNames(propertiesOfElement, element);
                firstRun = false;
            }

        // Parses the property values
        if (creationMode.CreateByPropertyValues)
            foreach (var element in elements.OfType<IElement>())
            {
                var hasProperties = element as IObjectAllProperties;
                if (hasProperties == null) continue;

                var propertiesOfElement = hasProperties.getPropertiesBeingSet().ToList();

                ThinOutPropertyNames(propertiesOfElement, element);
                firstRun = false;
            }

        void ThinOutPropertyNames(ICollection<string> propertiesOfElement, IElement element)
        {
            // Add the properties into the list, if first run or safe property
            foreach (var propertyName in propertiesOfElement)
            {
                if (firstRun)
                {
                    propertyNames.Add(propertyName);
                }
                else
                {
                    var isSafeProperty = DefaultClassifierHints.IsGenericProperty(element, propertyName);
                    if (isSafeProperty) propertyNames.Add(propertyName);
                }
            }

            // Check which properties are in the list but not in the object
            toBeDeleted.Clear();
            foreach (var propertyName in propertyNames)
            {
                var isSafeProperty = DefaultClassifierHints.IsGenericProperty(element, propertyName);
                if (!propertiesOfElement.Contains(propertyName) && !isSafeProperty) toBeDeleted.Add(propertyName);
            }

            // Now perform the deletion
            foreach (var propertyName in toBeDeleted) propertyNames.Remove(propertyName);
        }
    }

    /// <summary>
    ///     Creates a list form for a certain metaclass being used inside an extent form
    /// </summary>
    /// <param name="property">Property to be evaluated</param>
    /// <param name="creationMode"></param>
    public IElement CreateTableFormForProperty(IElement property, FormFactoryContext creationMode)
    {
        if (!creationMode.CreateByMetaClass)
            throw new InvalidOperationException("The list form will only be created for the metaclass");

        var propertyName = property.getOrDefault<string>(_UML._CommonStructure._NamedElement.name);
        var propertyType = PropertyMethods.GetPropertyType(property);

        var result = GetMofFactory(creationMode).create(_Forms.TheOne.__TableForm);

        FormMethods.AddToFormCreationProtocol(
            result,
            "[FormCreator.CreateTableFormForProperty] Created for Property: " + propertyName);

        if (propertyType != null) AddFieldsToRowOrTableFormByMetaClass(result, propertyType, creationMode);
        result.set(_Forms._TableForm.property, propertyName);
        result.set(_Forms._TableForm.title, $"{propertyName}");
        result.set(_Forms._TableForm.isAutoGenerated, true);

        CleanUpTableForm(result);
        return result;
    }

    public void CleanUpTableForm(IElement listForm)
    {
        AddTextFieldForNameIfNoFieldAvailable(listForm);
        SortFieldsByImportantProperties(listForm);
    }
}