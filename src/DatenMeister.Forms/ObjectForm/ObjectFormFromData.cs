using BurnSystems.Logging;
using DatenMeister.Core.EMOF.Implementation;
using DatenMeister.Core.EMOF.Interface.Common;
using DatenMeister.Core.EMOF.Interface.Reflection;
using DatenMeister.Core.Helper;
using DatenMeister.Core.Models;
using DatenMeister.Core.Models.EMOF;
using DatenMeister.Core.Runtime;
using DatenMeister.Core.Runtime.Workspaces;
using DatenMeister.Core.Uml.Helper;
using DatenMeister.Forms.FormCreator;
using DatenMeister.Forms.FormFactory;
using DatenMeister.Forms.FormFinder;
using DatenMeister.Forms.FormModifications;

namespace DatenMeister.Forms.ObjectForm;

public class ObjectFormFromData(IWorkspaceLogic workspaceLogic) : INewObjectFormFactory
{
    private static readonly ILogger Logger = new ClassLogger(typeof(ObjectFormFromData));

    /// <summary>
    /// Creates an object form for one specific item.
    /// The values and metaclass of the item are evaluated to create the form.  
    /// </summary>
    /// <param name="element">Element to be considered</param>
    /// <param name="context">The configuration of how to create the form</param>
    /// <param name="result">Reslt </param>
    /// <returns>The created form</returns>
    public void CreateObjectFormForItem(IObject element, NewFormCreationContext context, FormCreationResult result)
    {
        var factory = context.Global.Factory;

        var cache = new FormCreatorCache();

        // Creates the empty form
        var objectForm = factory.create(_Forms.TheOne.__ObjectForm);
        objectForm.set(
            _Forms._ObjectForm.name, 
            $"Object Form for '{NamedElementMethods.GetName(element)}'");
        objectForm.set(_Forms._ObjectForm.isAutoGenerated, true);

        FormMethods.AddToFormCreationProtocol(
            objectForm,
            "[FormCreator.CreateObjectFormForItem]: Create Object Form");

        var objectMetaClass = (element as IElement)?.getMetaClass();

        var tabs = new List<IElement>();

        // Get all properties of the elements
        var flagAddByMetaClass = true; //creationMode.CreateByMetaClass;
        List<CollectionFormCreator.P> propertyNamesWithCollection;
        List<CollectionFormCreator.P> propertyNamesWithoutCollection;

        // Adds the properties by the stored properties of the element
        if (true /*creationMode.CreateByPropertyValues*/)
        {
            var properties = (element as IObjectAllProperties)?.getPropertiesBeingSet().ToList();
            properties ??= new List<string>();

            propertyNamesWithCollection = (from p in properties
                where element.IsPropertyOfType<IReflectiveCollection>(p)
                let propertyContent = element.get<IReflectiveCollection>(p)
                where propertyContent != null
                select new CollectionFormCreator.P { PropertyName = p }).ToList();

            propertyNamesWithoutCollection = (from p in properties
                where !element.IsPropertyOfType<IReflectiveCollection>(p)
                let propertyContent = element.get(p)
                where propertyContent != null
                select new CollectionFormCreator.P { PropertyName = p }).ToList();
        }

        // Adds the properties by the metaclasses
        if (flagAddByMetaClass && objectMetaClass != null)
        {
            var metaClassProperties = ClassifierMethods.GetPropertiesOfClassifier(objectMetaClass);
            foreach (var property in metaClassProperties)
            {
                if (PropertyMethods.IsCollection(property))
                {
                    propertyNamesWithCollection.Add(
                        new CollectionFormCreator.P
                        {
                            PropertyName = NamedElementMethods.GetName(property),
                            PropertyType = PropertyMethods.GetPropertyType(property),
                            Property = property
                        });
                }
                    
                // As temporary workaround, we do also add the collections to the detail view
                propertyNamesWithoutCollection.Add(
                    new CollectionFormCreator.P
                    {
                        PropertyName = NamedElementMethods.GetName(property),
                        PropertyType = property,
                        Property = property
                    });
            }
        }

        // Remove duplicate properties in each of the collection
        var propertiesWithCollection =
            from p in propertyNamesWithCollection.Distinct(new CollectionFormCreator.P.PropertyNameEqualityComparer())
            let propertyContent = element.get<IReflectiveCollection>(p.PropertyName)
            select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent };

        var propertiesWithoutCollection =
            (from p in propertyNamesWithoutCollection.Distinct(new CollectionFormCreator.P.PropertyNameEqualityComparer())
                let propertyContent = element.getOrDefault<object>(p.PropertyName)
                select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent })
            .ToList();

        // Remove properties in propertiesWithoutCollection which are already available in propertiesWithCollection
        propertiesWithoutCollection = propertiesWithoutCollection
            .Where(x => propertiesWithCollection.All(y => y.propertyName != x.propertyName))
            .ToList();
            
        // We start with the detail form of type RowForm, we always need to have that form
        // because additional plugins might also add certain buttons to that form
        var detailForm = factory.create(_Forms.TheOne.__RowForm);
        detailForm.set(_Forms._RowForm.name, "Detail");
        detailForm.set(_Forms._RowForm.isAutoGenerated, true);
            
        tabs.Add(detailForm);
            
        FormMethods.AddToFormCreationProtocol(
            objectForm,
            "[FormCreator.CreateObjectFormForItem]: Create DetailForm into Extent");

        // Now, we got
        // propertyNamesWithCollection containing all properties which have a collection as a subitem ==> List Form
        // propertyNamesWithoutCollection containing all properties which have a collection as a subitem ==> Detail Form
        if (propertiesWithoutCollection.Any() || true /* creationMode.AutomaticMetaClassField */)
        {
            FormMethods.AddToFormCreationProtocol(
                objectForm,
                "[FormCreator.CreateObjectFormForItem]: Create DetailForm into Extent");

            foreach (var pair in propertiesWithoutCollection)
            {
                if (pair.propertyName == null)
                {
                    continue;
                }

                var property =
                    objectMetaClass == null
                        ? null
                        : ClassifierMethods.GetPropertyOfClassifier(objectMetaClass, pair.propertyName);

                var fieldResult = new FormCreationResult();
                var field = FormCreation.CreateFieldForProperty(property,
                    context,
                    fieldResult);

                if (field.Result != null)
                {
                    detailForm.AddCollectionItem(_Forms._RowForm.field, field.Result);
                }

                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Added field to DetailForm: " +
                    NamedElementMethods.GetName(field));
            }

            // Adds the metaclass field if not already added
            if (!cache.MetaClassAlreadyAdded
                && true /*creationMode.AutomaticMetaClassField*/
                && !FormMethods.HasMetaClassFieldInForm(
                    detailForm.get<IReflectiveCollection>(_Forms._RowForm.field)!))
            {
                // Add the element itself
                var metaClassField = factory.create(_Forms.TheOne.__MetaClassElementFieldData);
                metaClassField.set(_Forms._MetaClassElementFieldData.name, "Metaclass");
                detailForm.AddCollectionItem(_Forms._RowForm.field, metaClassField);

                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Added metaclass to DetailForm");

                cache.MetaClassAlreadyAdded = true;
            }
        }

        // Adds the properties with collection by adding table forms
        foreach (var pair in propertiesWithCollection)
        {
            var propertyName = pair.propertyName;
            var elementsAsObjects = pair.propertyContent.OfType<IObject>().ToList();

            // Special handling for packagedElement as container property for the childrens
            if (propertyName == _UML._Packages._Package.packagedElement)
            {
                // If the property for the list is 'packagedElement', then create multiple subforms...
                var elementsWithoutMetaClass = elementsAsObjects.Where(x =>
                {
                    if (x is IElement innerElement) return innerElement.getMetaClass() == null;

                    return true;
                }).ToList();

                var elementsWithMetaClass = elementsAsObjects
                    .OfType<IElement>()
                    .Select(x=>x.getMetaClass())
                    .Where(x => x != null)
                    .Distinct(new CollectionFormCreator.P.MofObjectComparer())
                    .OfType<IElement>();

                /*if (elementsWithoutMetaClass.Count != 0 || elementsAsObjects.Count == 0)
                {
                    // If there are elements included and they are filled
                    // OR, if there is no element included at all, create the corresponding list form
                    var form = factory.create(_Forms.TheOne.__TableForm);
                    form.set(_Forms._TableForm.name, "packagedElements without MetaClass");
                    form.set(_Forms._TableForm.property, propertyName);
                    form.set(_Forms._TableForm.noItemsWithMetaClass, true);
                    form.set(_Forms._TableForm.isAutoGenerated, true);

                    foreach (var item in elementsWithoutMetaClass)
                    {
                        AddFieldsToForm(form, item, creationMode, cache);
                    }

                    FormMethods.AddToFormCreationProtocol(
                        objectForm,
                        "[FormCreator.CreateObjectFormForItem]: Added specific Sub-TableForm for 'packagedElement' of propertyType: " +
                        NamedElementMethods.GetName(pair.propertyType));
                        
                    FormMethods.RemoveDuplicatingDefaultNewTypes(form);

                    tabs.Add(form);
                }*/

                foreach (var metaClass in elementsWithMetaClass)
                {
                    // Now try to figure out the metaclass
                    FormMethods.AddToFormCreationProtocol(
                        objectForm,
                        "[FormCreator.CreateObjectFormForItem]: Add Table Form for metaclass:" +
                        NamedElementMethods.GetName(metaClass));

                    var form = FormCreation.CreateTableFormForMetaClass(
                        metaClass,
                        context);
                    if (form.Result != null)
                    {
                        tabs.Add(form.Result);
                    }
                }
            }
            else
            {
                FormMethods.AddToFormCreationProtocol(
                    objectForm,
                    "[FormCreator.CreateObjectFormForItem]: Add Table Form for by reflective collection: " +
                    propertyName);

                // If there are elements included and they are filled
                // OR, if there is no element included at all, create the corresponding list form
                var form = FormCreation.CreateTableFormForCollection(
                    new TemporaryReflectiveCollection(elementsAsObjects),
                    context).Result;
                if (form != null)
                {
                    form.set(_Forms._TableForm.name, $"Property: {propertyName}");
                    form.set(_Forms._TableForm.property, propertyName);

                    // Adds the form to the tabs
                    tabs.Add(form);
                }
            }
        }

        // ReSharper restore HeuristicUnreachableCode
        objectForm.set(_Forms._ObjectForm.tab, tabs);

        result.IsManaged = true;
        result.IsMainContentCreated = true;
        result.Result = objectForm;
    }

    /// <summary>
    /// Creates an object form by the metaclass definition
    /// </summary>
    /// <param name="metaClass">Metaclass to be queried</param>
    /// <param name="context">The form configuration to be used</param>
    /// <returns>The found or created form. If none is found, then null will be returned </returns>
    public void CreateObjectFormForMetaClass(IElement metaClass, NewFormCreationContext context, FormCreationResult result)
    {
    }
}