using BurnSystems.Logging;
using DatenMeister.Core.EMOF.Implementation;
using DatenMeister.Core.EMOF.Interface.Common;
using DatenMeister.Core.EMOF.Interface.Reflection;
using DatenMeister.Core.Helper;
using DatenMeister.Core.Models;
using DatenMeister.Core.Models.EMOF;
using DatenMeister.Core.Uml.Helper;
using DatenMeister.Forms.Fields;
using DatenMeister.Forms.FormFactory;
using DatenMeister.Forms.Helper;
using DatenMeister.Forms.RowForm;

namespace DatenMeister.Forms.ObjectForm;

public class ObjectFormFromData : IObjectFormFactory
{
    private static readonly ILogger Logger = new ClassLogger(typeof(ObjectFormFromData));

    /// <summary>
    /// Creates an object form for one specific item.
    /// The values and metaclass of the item are evaluated to create the form.  
    /// </summary>
    /// <param name="parameter">Parameter to be considered</param>
    /// <param name="context">The configuration of how to create the form</param>
    /// <param name="result">Result of the activity</param>
    /// <returns>The created form</returns>
    public void CreateObjectForm(
        ObjectFormFactoryParameter parameter,
        FormCreationContext context,
        FormCreationResultOneForm result)
    {
        if (result.IsMainContentCreated)
            return;
        
        var element = parameter.Element;
        var factory = context.Global.Factory;
        result.Form ??= factory.create(_Forms.TheOne.__ObjectForm);
        
        if(element != null)
        {
            var cache = new FormCreatorCache();

            // Creates the empty form
            result.Form.set(
                _Forms._ObjectForm.name,
                $"Object Form for '{NamedElementMethods.GetName(element)}'");
            result.Form.set(_Forms._ObjectForm.isAutoGenerated, true);

            result.AddToFormCreationProtocol(
                "[ObjectFormFromData.CreateObjectFormForItem]: Create Object Form");

            var objectMetaClass = (element as IElement)?.getMetaClass();

            var tabs = new List<IElement>();

            // Get all properties of the elements
            List<FieldCreationHelper.P> propertyNamesWithCollection;
            List<FieldCreationHelper.P> propertyNamesWithoutCollection;

            // Adds the properties by the stored properties of the element
            if (true /*creationMode.CreateByPropertyValues*/)
            {
                var properties = (element as IObjectAllProperties)?.getPropertiesBeingSet().ToList();
                properties ??= new List<string>();

                propertyNamesWithCollection = (from p in properties
                    where element.IsPropertyOfType<IReflectiveCollection>(p)
                    let propertyContent = element.get<IReflectiveCollection>(p)
                    where propertyContent != null
                    select new FieldCreationHelper.P { PropertyName = p }).ToList();

                propertyNamesWithoutCollection = (from p in properties
                    where !element.IsPropertyOfType<IReflectiveCollection>(p)
                    let propertyContent = element.get(p)
                    where propertyContent != null
                    select new FieldCreationHelper.P { PropertyName = p }).ToList();
            }

            // Adds the properties by the metaclasses
            if (objectMetaClass != null)
            {
                var metaClassProperties = ClassifierMethods.GetPropertiesOfClassifier(objectMetaClass);
                foreach (var property in metaClassProperties)
                {
                    if (PropertyMethods.IsCollection(property))
                    {
                        propertyNamesWithCollection.Add(
                            new FieldCreationHelper.P
                            {
                                PropertyName = NamedElementMethods.GetName(property),
                                PropertyType = PropertyMethods.GetPropertyType(property),
                                Property = property
                            });
                    }

                    // As temporary workaround, we do also add the collections to the detail view
                    propertyNamesWithoutCollection.Add(
                        new FieldCreationHelper.P
                        {
                            PropertyName = NamedElementMethods.GetName(property),
                            PropertyType = property,
                            Property = property
                        });
                }
            }

            // Remove duplicate properties in each of the collection
            var propertiesWithCollection =
                from p in propertyNamesWithCollection.Distinct(new FieldCreationHelper.P.PropertyNameEqualityComparer())
                let propertyContent = element.get<IReflectiveCollection>(p.PropertyName)
                select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent };

            var propertiesWithoutCollection =
                (from p in propertyNamesWithoutCollection.Distinct(
                        new FieldCreationHelper.P.PropertyNameEqualityComparer())
                    let propertyContent = element.getOrDefault<object>(p.PropertyName)
                    select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent })
                .ToList();

            // Remove properties in propertiesWithoutCollection which are already available in propertiesWithCollection
            propertiesWithoutCollection = propertiesWithoutCollection
                .Where(x => propertiesWithCollection.All(y => y.propertyName != x.propertyName))
                .ToList();

            // We start with the detail form of type RowForm, we always need to have that form
            // because additional plugins might also add certain buttons to that form
            var detailForm = FormCreation.CreateRowForm(
                new RowFormFactoryParameter()
                {
                    Element = element,
                    Extent = parameter.Extent,
                    ExtentTypes = parameter.ExtentTypes,
                },
                context.Clone()).Forms.FirstOrDefault();
            
            // In case, the original form does not 
            if (detailForm == null)
            {
                var detailResult = new FormCreationResultMultipleForms();
                new EmptyRowFormFactory().CreateRowForm(
                    new RowFormFactoryParameter(), context.Clone(), detailResult);
                detailForm = detailResult.Forms.FirstOrDefault() ?? throw new InvalidOperationException(
                    "detailForm == null, it should not happen by EmptyRowFormFactory");
            }
            
            detailForm.set(_Forms._RowForm.name, "Detail");
            detailForm.set(_Forms._RowForm.isAutoGenerated, true);

            tabs.Add(detailForm);

            result.AddToFormCreationProtocol(
                "[ObjectFormFromData.CreateObjectFormForItem]: Create DetailForm into Extent");

            
            // Adds the properties with collection by adding table forms
            foreach (var pair in propertiesWithCollection)
            {
                var listForm = FormCreation.CreateTableForm(
                    new TableFormFactoryParameter()
                    {
                        Extent = parameter.Extent,
                        ExtentTypes = parameter.ExtentTypes,
                        Collection = pair.propertyContent,
                        MetaClass = pair.propertyType
                    },
                    context.Clone()).Forms;

                foreach (var form in listForm)
                {
                    tabs.Add(form);
                }
            }

            // ReSharper restore HeuristicUnreachableCode
            result.Form.set(_Forms._ObjectForm.tab, tabs);
            result.IsManaged = result.IsMainContentCreated = true;
        }
    }
}