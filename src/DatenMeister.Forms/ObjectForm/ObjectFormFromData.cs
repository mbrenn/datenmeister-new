using BurnSystems.Logging;
using DatenMeister.Core.EMOF.Implementation;
using DatenMeister.Core.EMOF.Interface.Common;
using DatenMeister.Core.EMOF.Interface.Reflection;
using DatenMeister.Core.Helper;
using DatenMeister.Core.Models;
using DatenMeister.Core.Models.EMOF;
using DatenMeister.Core.Uml.Helper;
using DatenMeister.Forms.Fields;
using DatenMeister.Forms.FormFactory;
using DatenMeister.Forms.Helper;

namespace DatenMeister.Forms.ObjectForm;

public class ObjectFormFromData : IObjectFormFactory
{
    private static readonly ILogger Logger = new ClassLogger(typeof(ObjectFormFromData));

    /// <summary>
    /// Creates an object form for one specific item.
    /// The values and metaclass of the item are evaluated to create the form.  
    /// </summary>
    /// <param name="parameter">Parameter to be considered</param>
    /// <param name="context">The configuration of how to create the form</param>
    /// <param name="result">Result of the activity</param>
    /// <returns>The created form</returns>
    public void CreateObjectForm(
        ObjectFormFactoryParameter parameter,
        FormCreationContext context,
        FormCreationResult result)
    {
        if (result.IsMainContentCreated)
            return;
        
        var element = parameter.Element;
        var parameterMetaclass = parameter.MetaClass;
        var factory = context.Global.Factory;
        result.Form ??= factory.create(_Forms.TheOne.__ObjectForm);

        if (parameterMetaclass != null)
        {
            result.Form.set(_Forms._RowForm.isAutoGenerated, true);
            result.Form.set(
                _Forms._RowForm.name,
                $"Object Form for '{NamedElementMethods.GetFullName(parameterMetaclass)}'");

            var rowForm = FormCreation.CreateRowForm(
                new RowFormFactoryParameter
                {
                    MetaClass = parameterMetaclass,
                    ExtentTypes = parameter.ExtentTypes,
                    Extent = parameter.Extent
                }, context.Clone());

            result.Form.set(_Forms._CollectionForm.tab, new[] { rowForm });

            result.IsManaged = result.IsMainContentCreated = true;
        }
        else if(element != null)
        {
            var cache = new FormCreatorCache();

            // Creates the empty form
            result.Form.set(
                _Forms._ObjectForm.name,
                $"Object Form for '{NamedElementMethods.GetName(element)}'");
            result.Form.set(_Forms._ObjectForm.isAutoGenerated, true);

            result.AddToFormCreationProtocol(
                "[ObjectFormFromData.CreateObjectFormForItem]: Create Object Form");

            var objectMetaClass = (element as IElement)?.getMetaClass();

            var tabs = new List<IElement>();

            // Get all properties of the elements
            var flagAddByMetaClass = true; //creationMode.CreateByMetaClass;
            List<FieldCreationHelper.P> propertyNamesWithCollection;
            List<FieldCreationHelper.P> propertyNamesWithoutCollection;

            // Adds the properties by the stored properties of the element
            if (true /*creationMode.CreateByPropertyValues*/)
            {
                var properties = (element as IObjectAllProperties)?.getPropertiesBeingSet().ToList();
                properties ??= new List<string>();

                propertyNamesWithCollection = (from p in properties
                    where element.IsPropertyOfType<IReflectiveCollection>(p)
                    let propertyContent = element.get<IReflectiveCollection>(p)
                    where propertyContent != null
                    select new FieldCreationHelper.P { PropertyName = p }).ToList();

                propertyNamesWithoutCollection = (from p in properties
                    where !element.IsPropertyOfType<IReflectiveCollection>(p)
                    let propertyContent = element.get(p)
                    where propertyContent != null
                    select new FieldCreationHelper.P { PropertyName = p }).ToList();
            }

            // Adds the properties by the metaclasses
            if (flagAddByMetaClass && objectMetaClass != null)
            {
                var metaClassProperties = ClassifierMethods.GetPropertiesOfClassifier(objectMetaClass);
                foreach (var property in metaClassProperties)
                {
                    if (PropertyMethods.IsCollection(property))
                    {
                        propertyNamesWithCollection.Add(
                            new FieldCreationHelper.P
                            {
                                PropertyName = NamedElementMethods.GetName(property),
                                PropertyType = PropertyMethods.GetPropertyType(property),
                                Property = property
                            });
                    }

                    // As temporary workaround, we do also add the collections to the detail view
                    propertyNamesWithoutCollection.Add(
                        new FieldCreationHelper.P
                        {
                            PropertyName = NamedElementMethods.GetName(property),
                            PropertyType = property,
                            Property = property
                        });
                }
            }

            // Remove duplicate properties in each of the collection
            var propertiesWithCollection =
                from p in propertyNamesWithCollection.Distinct(new FieldCreationHelper.P.PropertyNameEqualityComparer())
                let propertyContent = element.get<IReflectiveCollection>(p.PropertyName)
                select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent };

            var propertiesWithoutCollection =
                (from p in propertyNamesWithoutCollection.Distinct(
                        new FieldCreationHelper.P.PropertyNameEqualityComparer())
                    let propertyContent = element.getOrDefault<object>(p.PropertyName)
                    select new { propertyName = p.PropertyName, propertyType = p.PropertyType, propertyContent })
                .ToList();

            // Remove properties in propertiesWithoutCollection which are already available in propertiesWithCollection
            propertiesWithoutCollection = propertiesWithoutCollection
                .Where(x => propertiesWithCollection.All(y => y.propertyName != x.propertyName))
                .ToList();

            // We start with the detail form of type RowForm, we always need to have that form
            // because additional plugins might also add certain buttons to that form
            var detailForm = factory.create(_Forms.TheOne.__RowForm);
            detailForm.set(_Forms._RowForm.name, "Detail");
            detailForm.set(_Forms._RowForm.isAutoGenerated, true);

            tabs.Add(detailForm);

            result.AddToFormCreationProtocol(
                "[ObjectFormFromData.CreateObjectFormForItem]: Create DetailForm into Extent");

            // Now, we got
            // propertyNamesWithCollection containing all properties which have a collection as a subitem ==> List Form
            // propertyNamesWithoutCollection containing all properties which have a collection as a subitem ==> Detail Form
            if (propertiesWithoutCollection.Any() || true /* creationMode.AutomaticMetaClassField */)
            {
                result.AddToFormCreationProtocol(
                    "[ObjectFormFromData.CreateObjectFormForItem]: Create DetailForm into Extent");

                foreach (var pair in propertiesWithoutCollection)
                {
                    if (pair.propertyName == null)
                    {
                        continue;
                    }

                    var property =
                        objectMetaClass == null
                            ? null
                            : ClassifierMethods.GetPropertyOfClassifier(objectMetaClass, pair.propertyName);

                    var fieldResult = new FormCreationResult();
                    var field = FormCreation.CreateFieldForProperty(
                        new FieldFactoryParameter
                        {
                            PropertyType = property,
                            PropertyName = pair.propertyName
                        },
                        context.Clone(),
                        fieldResult);

                    if (field.Form != null)
                    {
                        detailForm.AddCollectionItem(_Forms._RowForm.field, field.Form);
                    }

                    result.AddToFormCreationProtocol(
                        "[ObjectFormFromData.CreateObjectFormForItem]: Added field to DetailForm: " +
                        NamedElementMethods.GetName(field));
                }

                // Adds the metaclass field if not already added
                if (!cache.MetaClassAlreadyAdded
                    && true /*creationMode.AutomaticMetaClassField*/
                    && !FormMethods.HasMetaClassFieldInForm(
                        detailForm.get<IReflectiveCollection>(_Forms._RowForm.field)!))
                {
                    // Add the element itself
                    var metaClassField = factory.create(_Forms.TheOne.__MetaClassElementFieldData);
                    metaClassField.set(_Forms._MetaClassElementFieldData.name, "Metaclass");
                    detailForm.AddCollectionItem(_Forms._RowForm.field, metaClassField);

                    result.AddToFormCreationProtocol(
                        "[ObjectFormFromData.CreateObjectFormForItem]: Added metaclass to DetailForm");

                    cache.MetaClassAlreadyAdded = true;
                }
            }

            // Adds the properties with collection by adding table forms
            foreach (var pair in propertiesWithCollection)
            {
                var propertyName = pair.propertyName;
                var elementsAsObjects = pair.propertyContent.OfType<IObject>().ToList();

                // Special handling for packagedElement as container property for the childrens
                if (propertyName == _UML._Packages._Package.packagedElement)
                {
                    // If the property for the list is 'packagedElement', then create multiple subforms...
                    var elementsWithoutMetaClass = elementsAsObjects.Where(x =>
                    {
                        if (x is IElement innerElement) return innerElement.getMetaClass() == null;

                        return true;
                    }).ToList();

                    var elementsWithMetaClass = elementsAsObjects
                        .OfType<IElement>()
                        .Select(x => x.getMetaClass())
                        .Where(x => x != null)
                        .Distinct(new FieldCreationHelper.P.MofObjectComparer())
                        .OfType<IElement>();

                    /*if (elementsWithoutMetaClass.Count != 0 || elementsAsObjects.Count == 0)
                    {
                        // If there are elements included and they are filled
                        // OR, if there is no element included at all, create the corresponding list form
                        var form = factory.create(_Forms.TheOne.__TableForm);
                        form.set(_Forms._TableForm.name, "packagedElements without MetaClass");
                        form.set(_Forms._TableForm.property, propertyName);
                        form.set(_Forms._TableForm.noItemsWithMetaClass, true);
                        form.set(_Forms._TableForm.isAutoGenerated, true);

                        foreach (var item in elementsWithoutMetaClass)
                        {
                            AddFieldsToForm(form, item, creationMode, cache);
                        }

                        FormMethods.AddToFormCreationProtocol(
                            objectForm,
                            "[FormCreator.CreateObjectFormForItem]: Added specific Sub-TableForm for 'packagedElement' of propertyType: " +
                            NamedElementMethods.GetName(pair.propertyType));

                        FormMethods.RemoveDuplicatingDefaultNewTypes(form);

                        tabs.Add(form);
                    }*/

                    foreach (var metaClass in elementsWithMetaClass)
                    {
                        // Now try to figure out the metaclass
                        result.AddToFormCreationProtocol(
                            "[ObjectFormFromData.CreateObjectFormForItem]: Add Table Form for metaclass:" +
                            NamedElementMethods.GetName(metaClass));

                        var form = FormCreation.CreateTableFormForMetaClass(
                            new TableFormFactoryParameter
                            {
                                MetaClass = metaClass,
                                Extent = parameter.Extent,
                                ExtentTypes = parameter.ExtentTypes
                            }, context);
                        if (form.Form != null)
                        {
                            tabs.Add(form.Form);
                        }
                    }
                }
                else
                {
                    result.AddToFormCreationProtocol(
                        "[ObjectFormFromData.CreateObjectFormForItem]: Add Table Form for by reflective collection: " +
                        propertyName);

                    // If there are elements included and they are filled
                    // OR, if there is no element included at all, create the corresponding list form
                    var form = FormCreation.CreateTableFormForMetaClass(
                        new TableFormFactoryParameter
                        {
                            Collection = new TemporaryReflectiveCollection(elementsAsObjects)
                        }, context.Clone()).Form;
                    if (form != null)
                    {
                        form.set(_Forms._TableForm.name, $"Property: {propertyName}");
                        form.set(_Forms._TableForm.property, propertyName);

                        // Adds the form to the tabs
                        tabs.Add(form);
                    }
                }
            }

            // ReSharper restore HeuristicUnreachableCode
            result.Form.set(_Forms._ObjectForm.tab, tabs);

            result.IsManaged = result.IsMainContentCreated = true;
        }
    }
}